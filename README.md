__**Рафиков Роман Викторович УИБО-14-24**__
__________________________________________________________

Алгоритмы сортировки

Сортировка выбором (Selection Sort)

Алгоритм последовательного нахождения минимальных элементов с их перемещением в начало массива

Выбранный язык C++

Исходный массив: 64, 25, 12, 22, 11
Отсортированный массив:11, 12, 22, 25, 64

Принцип работы:

· На каждом этапе в необработанной части находится минимальный элемент
· Обнаруженный минимум обменивается с текущим элементом
· Отсортированный участок постепенно увеличивается с левого края

Эффективность: O(n²) для всех случаев


Сортировка обменом (пузырьком) (Bubble Sort)

Метод многократного прохода по массиву с сравнением и обменом соседних элементов

Выбранный язык Python

Исходный массив: 64 34 25 12 22 11 90
Отсортированный массив:11 12 22 25 34 64 90

Принцип работы:

· Последовательное сравнение пар соседних элементов
· При нарушении порядка происходит обмен местами
· Крупные значения постепенно перемещаются к правому краю

Эффективность: O(n²) в стандартном случае, O(n) для упорядоченных данных


Сортировка вставками (Insertion Sort)

Поэтапное построение упорядоченной последовательности путем вставки элементов

Выбранный язык C++

Исходный массив: 12 11 13 5 6
Отсортированный массив:5 6 11 12 13

Принцип работы:

· Массив разделен на отсортированную и неотсортированную части
· Каждый новый элемент вставляется в правильную позицию
· Элементы большие вставляемого сдвигаются вправо

Эффективность: O(n²) в общем случае, O(n) для упорядоченных данных


Сортировка слиянием (Merge Sort)

Алгоритм разделения массива на части с последующим слиянием

Выбранный язык C++

Исходный массив: 38 27 43 3 9 82 10
Отсортированный массив:3 9 10 27 38 43 82

Принцип работы:

· Рекурсивное деление массива пополам
· Слияние отсортированных частей в правильном порядке
· Сравнение и объединение элементов из двух подмассивов

Эффективность: O(n log n) для всех случаев


Сортировка Шелла (Shellsort)

Усовершенствованная сортировка вставками с переменным шагом

Выбранный язык Python

Исходный массив: 12 34 54 2 3
Отсортированный массив:2 3 12 34 54

Принцип работы:

· Использование последовательности интервалов для сравнения
· Сравнение элементов на определенном расстоянии
· Постепенное уменьшение шага до единицы

Эффективность: O(n²) в худшем случае, O(n log²n) в среднем


Быстрая сортировка (Quick Sort)

Эффективный алгоритм на основе разделения относительно опорного элемента

Выбранный язык C++

Исходный массив: 10 7 8 9 1 5
Отсортированный массив:1 5 7 8 9 10

Принцип работы:

· Выбор опорного элемента (pivot)
· Разделение на элементы меньше и больше опорного
· Рекурсивная обработка обеих частей

Эффективность: O(n log n) в среднем, O(n²) в худшем случае


Пирамидальная сортировка (Heap Sort)

Сортировка с использованием структуры двоичной кучи

Выбранный язык C++

Исходный массив: 12 11 13 5 6 7
Отсортированный массив:5 6 7 11 12 13

Принцип работы:

· Построение max-heap из исходного массива
· Перемещение корня кучи в конец массива
· Перестроение кучи с уменьшенным размером

Эффективность: O(n log n) для всех случаев


Алгоритмы поиска

Последовательный (линейный) поиск

Простой метод перебора элементов от начала до конца

Выбранный язык Python

Результат: Элемент найден на позиции 3

Принцип работы:

· Поочередная проверка каждого элемента массива
· Возврат индекса при нахождении совпадения
· Возврат -1 при отсутствии элемента

Эффективность: O(n) в худшем случае, O(1) в лучшем


Бинарный (двоичный) поиск

Поиск в упорядоченном массиве методом деления пополам

Выбранный язык Python

Результат: Элемент найден на позиции 3

Принцип работы:

· Поиск выполняется в отсортированном массиве
· На каждом шаге область поиска уменьшается вдвое
· Сравнение с центральным элементом диапазона

Эффективность: O(log n) в среднем и худшем случаях


Интерполирующий поиск

Улучшенный поиск для равномерно распределенных данных

Выбранный язык C++

Результат: Элемент найден на позиции 4

Принцип работы:
· Вычисление вероятной позиции по интерполяционной формуле
· Рекурсивное сужение области поиска
· Эффективен при равномерном распределении значений

Эффективность: O(log log n) в среднем, O(n) в худшем случае


Поиск по Фибоначчи

Алгоритм с использованием чисел Фибоначчи для определения позиций

Выбранный язык Python

Результат: Элемент найден на позиции 8

Принцип работы:

· Деление массива в пропорциях Фибоначчи
· Определение позиций сравнения по последовательности
· Эффективен при дорогостоящих операциях сравнения

Эффективность: O(log n) для всех случаев
